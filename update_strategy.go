/*
Copyright 2023 Kubespress Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package objects

import (
	"crypto/sha1"
	"encoding/hex"

	"github.com/davecgh/go-spew/spew"
	"github.com/kubespress/objects/equality"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// DefaultUpdateStrategy is the default update strategy to use. This defaults to the DeepEqualStrategy.
var DefaultUpdateStrategy = DeepEqualUpdateStrategy(equality.Semantic)

// UpdateStrategy is used to decide if an update is required to the Kubernetes object.
type UpdateStrategy interface {
	// PreUpdate gets called before the object is created in Kubernetes. It allows the strategy to mutate the object
	// prior to the update. This is useful for strategies that store information within the Kubernetes object itself.
	PreCreate(create client.Object)
	// RequiresUpdate returns true if the object requires an update. The strategy is passed three versions of the
	// object. The "existing" object is the object as it exists in Kubernetes The "create" object is the object that
	// would be created if it did not exist, this is generated by running the build functions against a zero instance of
	// the object (with the OpCreate operation). The "update" object is the pending update, it is generated by running
	// the build functions gainst the existing object (with the OpUpdate operation). Any changes to the "update" object
	// will be persisted within Kubernetes.
	RequiresUpdate(existing, create, update client.Object) bool
}

// Compile time check to ensure strategyDeepEqual implements UpdateStrategy
var _ UpdateStrategy = &strategyDeepEqual{}

type strategyDeepEqual struct {
	eq equality.Equalities
}

// DeepEqualUpdateStrategy determines if an object requires an update by comparing the object that would be used in the
// update against the existing object. Since the build functions run against the existing object, this should handle
// most cases and is the default strategy.
//
// The equality package is used and changes to the status field are ignored.
func DeepEqualUpdateStrategy(eq equality.Equalities) UpdateStrategy {
	return &strategyDeepEqual{
		eq: eq,
	}
}

func (s *strategyDeepEqual) PreCreate(client.Object) {
	// Nothing to do
}

func (s *strategyDeepEqual) RequiresUpdate(existing, create, update client.Object) bool {
	return !equality.ObjectsEqualWithoutStatus(s.eq, existing, update)
}

// Compile time check to ensure strategyDeepEqual implements UpdateStrategy
var _ UpdateStrategy = &strategyHash{}

type strategyHash struct {
	key string
}

// HashUpdateStrategy performs a SHA1 hash of the creation object prior to both create and update. This hash is stored
// as an annotation with the specified key.
//
// An object is only updated if the computed hash does not match the hash on the object. Given it is the creation object
// that is hashed, this allows fields to be mutated and updated without intervention of the controller. This is useful
// for complex objects such as Pods that may have extra containers or volumes injected in where handling all the cases
// in the build functions would be overly complex.
func HashUpdateStrategy(key string) UpdateStrategy {
	return &strategyHash{key: key}
}

func (s *strategyHash) PreCreate(obj client.Object) {
	// Hash the object
	hash := s.deepHashObject(obj)

	// Insert the hash as an annotation
	mapInsert(obj.GetAnnotations, obj.SetAnnotations, s.key, hash)
}

func (s *strategyHash) RequiresUpdate(existing, create, update client.Object) bool {
	// Get the annotation on the create object
	createAnnotations := create.GetAnnotations()

	// Get the hash from the annotations, or if not set (it should be set by
	// the PreCreate method), generate it
	hash, exists := createAnnotations[s.key]
	if !exists {
		hash = s.deepHashObject(create)
	}

	// Get the annotations map from the existing object
	existingAnnotations := existing.GetAnnotations()

	// Get the current hash from the annotation
	currentHash, exists := existingAnnotations[s.key]

	// If the hash matches, their is no update required
	if exists && currentHash == hash {
		return false
	}

	// Insert the hash as an annotation on the update object
	mapInsert(update.GetAnnotations, update.SetAnnotations, s.key, hash)

	// Update is required, return true
	return true
}

func (s *strategyHash) deepHashObject(obj interface{}) string {
	// Create new hash instance
	hash := sha1.New()

	// Create spew config
	printer := spew.ConfigState{
		Indent:         " ",
		SortKeys:       true,
		DisableMethods: true,
		SpewKeys:       true,
	}

	// Spew into hasher
	printer.Fprintf(hash, "%#v", obj)

	// Return the hash
	return hex.EncodeToString(hash.Sum(nil))
}
